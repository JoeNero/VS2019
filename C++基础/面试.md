# const与#define相比，区别和优点

## 一：区别


（1）就起作用的阶段而言： #define是在编译的预处理阶段起作用，而const是在 编译、运行的时候起作用。
（2）就起作用的方式而言： #define只是简单的字符串替换，没有类型检查。而const有对应的数据类型，是要进行判断的，可以避免一些低级的错误。 
（3）就存储方式而言：#define只是进行展开，有多少地方使用，就替换多少次，它定义的宏常量在内存中有若干个备份；const定义的只读变量在程序运行过程中只有一份备份。
（4）从代码调试的方便程度而言： const常量可以进行调试的，define是不能进行调试的，因为在预编译阶段就已经替换掉了。
## 二：const优点


（1）const常量有数据类型，而宏常量没有数据类型。编译器可以对前者进行类型安全检查。而对后者只进行字符替换，没有类型安全检查，并且在字符替换可能会产生意料不到的错误。
（2）有些集成化的调试工具可以对const常量进行调试，但是不能对宏常量进行调试。
（3）const可节省空间，避免不必要的内存分配，提高效率

# static 
## 隐藏

	当同时编译多个文件时，所有未加static前缀的全局变量和函数都具有全局可见性。
	而加了static的变量会对其他文件隐藏
	
## 保持变量内容持久

	如果作为static局部变量在函数内定义，它的生存期为整个源程序，
	但是其作用域仍与自动变量相同，只能在定义该变量的函数内使用该变量。
	退出该函数后， 尽管该变量还继续存在，但不能使用它。
	
## 默认初始化0

# new 和 delete
		new:分配内存、调用构造函数
		
##(1)new的底层也是通过malloc来开辟内存的
		new比malloc多一项功能，就是开辟完内存，还可以进行初始化操作
		如下：
				```
					int *p = new int(10);
				```
		上面是new的基本操作，10代表堆上开辟的整形内存的初始值；如果是自定义类类型的话，如下：
		```
		Test *p = new Test();
		```

		这个语句不仅会在堆上开辟Test类型大小的一块内存，还会调用Test类的默认构造函数构造一个对象出来，这些都是malloc办不到的！

##(2)delete比free多一项功能就是在释放内存之前，还可以析构指针指向的对象，new和delete配对使用，new[]和delete[]配对使用，尽量不要交叉使用，以免产生不可预期的问题。

##(3)new开辟内存失败是抛出bad_alloc类型的异常，因此代码上要捕获该类型的异常才能正确的判断堆内存是否分配成功；malloc内存开辟失败返回的是nullptr指针。

##(4）new和delete不仅仅是运算符，它们实际上是运算符重载函数的调用，对应的函数名是operator new和operator delete，可以在全局或者类的作用域中提供自定义的new和delete运算符的重载函数，以改变默认的malloc和free内存开辟释放行为，比如说实现内存池。

## delete this 一般用于线程自杀